%!TEX root= ./master.tex

\chapter{CAN Bus Automation and the Carduino}
\section{Abstract}
A device named the Carduino was created which allows the user to upload Arduino sketches via an Arduino shield, but be detached later for use in an automotive environment. The circuit has both analogue and digital inputs, and is able to output PWM signals, as well as digital logic high or lows. It has been designed to be a user friendly solution to the issue of automotive automation amongst SAE students/hobby motor enthusiasts.

\section{Introduction}
One of the major areas for innovation in the automotive industry involves the utilisation of automated components. In order to achieve this automation, the Controller Area Network (CAN) protocol has been adopted almost universally to facilitate the propagation of signals throughout cars without the need for extra circuitry to provide bus arbitration and data flow management\cite{CAN_standard}. Another huge advantage to this protocol is that it only requires two wires connected to each device (other than power). Currently, the team makes use of this protocol for communication between the M400, PDM and ADL3, however this is via MOTEC software and hardware, which is closed source, and extremely inflexible in terms of what you are able to send and receive over the CAN bus. It was decided that the CAN bus should be explored further to see what options are available to future electrical teams in terms of automation.\\

The goal was to develop a circuit which was easily programmable, and which would allow the user to develop programs which interface with the CAN bus. This would allow the user to create systems which are actuated in response to signals from the M400, ADL3, or any other device attached to the CAN bus, including other copies of this device. It would feature the ability to read in signals from sensors or any other electrical source, and output PWM signals based on either its own input or the messages it receives via the CAN bus. With the creation of this device comes the potential for future electrical teams to develop systems for future years' cars which would benefit from automation. Examples of such systems may be dynamic drag reduction, active suspension, or anything the engineer deems useful for the car.

\subsection{Problem Definition}
\subsubsection{MOTEC and Proprietary Hardware/Software}
One of the major issues encountered when trying to develop systems on the car with the equipment currently owned is that it must incorporate proprietary MOTEC software and hardware such as the M400 and the ADL3, which are the backbone of the CAN bus implementation currently onboard the car. MOTEC equipment is closed source and strictly controlled by MOTEC themselves as part of their business model to generate higher revenue\cite{MOTEC_prices}. If future EE teams are to be able to create and implement more sophisticated technologies on the car, an alternative to the closed source solution MOTEC equipment delivers needed to be found. 

\subsubsection{CAN Protocol Inconsistencies}
Another major issue regarding the CAN bus is the fact that there is no standardised protocol for the data that is actually encapsulated in the packets being sent and received. This means that almost every car manufacturer has developed their own protocol for use in their cars, and their cars only. It is commonplace for these CAN protocols to be protected by copyright, and for mechanics to purchase devices worth thousands of dollars just because it contains the intellectual property required to decode the packets sent over the CAN bus. This means that in order to create a truly open source interface to the CAN bus, a new protocol is required. The solution developed needed to include a basic set of instructions and a library for sending and receiving them, but more importantly needed the building blocks for the user to create more instructions as they see fit.

figure of CAN packets with a Holden symbol in it, and a ford symbol in another one or something, then the carduino protocol in a third.

\subsubsection{Form Factor, Physical Realisation, Durability}
The most important issue to be considered when developing this product is the physical package which the device will come in, and how it will be programmed. The implementation of devices in automotive environments requires a level of robustness above and beyond the standard level to which most electrical devices are manufactured. The device must be able to withstand vibrations, being accidentally hit by tools, extreme heat if placed near the engine, and be waterproof since the device will most likely be exposed to the elements. For this reason the Carduino device must preferably be small, and most likely inside a waterproof/heatproof/knock-proof container.

\section{Literature Review}
\subsection{Introduction}
Being the standard communication protocol used by the automotive industry, there are many devices available today which interface with the CAN Bus. This literature review will detail a comparison of all other similar solutions available on the market today, and the reasoning behind the final form decided on for the Carduino, from a hardware and software perspective. It should be noted that the name `Carduino' was created retrospectively after deciding that the device would based on the Arduino infrastructure, and thus many other potential solutions were explored before settling upon an Arduino based solution.

\subsection{Review}
\subsubsection{Arduino Shields}
One of the first options explored for interfacing with the CAN Bus involved using an Arduino shield, like the one available from Sprakfun\cite{CAN_arduinoshield}. The shield basically provides a connection from the microcontroller onboard the Arduino to the MCP2515 chip. The MCP2515 is designed specifically for taking in messages via the Serial Peripheral Interface (SPI), and transmitting those messages over a CAN bus according to the CAN protocol\cite{MCP2515_datasheet}. Providing the functionality of the MCP2515 chip along with the programmability of the Arduino matches the core functionality required from the device, so an Arduino shield is a good option. Certainly for testing the code and the concepts behind CAN communication, this option presented an excellent stepping stone onto other more appropriate solutions, especially if the MCP2515 was to be the interface for the CAN Bus onboard the device. The main drawback involved with this design is that the form factor of the Arduino/shield combo is far too large for practical implementation on a race car. In order to ensure reliability in the extreme environment which the race car provides, a much smaller and more ruggedised solution needed to be found for the final form of this device.

\subsubsection{MOTEC DBW-4 Drive by Wire Module}
Simiarly to the telemetry solution, there is an existing MOTEC solution which provides similar functionality to that required from the Carduino device. The MOTEC device is called the DBW-4. The DBW-4 offers the user 4 PID controllers for Drive By Wire Control, or generic PID control for servo motors\cite{DBW4_manual}\cite{MOTEC_prices}. Drive By Wire is the term used in the automotive industry to somewhat counter intuitively denote a system where the intake throttle position is actuated not by a physical wire connecting the throttle pedal to the intake throttle, but by an electronic signal from the throttle pedal position sensors processed by the car's ECU\cite{pruckner2012drive}. This method is common in modern cars, as it allows the engineers programming the car to control certain aspects of how the engine will respond to the driver's use of the throttle\cite{DBW}. An example of this would be applying a lowpass filter on the throttle pedal position, to ensure a smoother ride is more easily achieved by the driver. The drawback to this is that the throttle position is one of the most important inputs the driver has to the car, and hence it is of the utmost importance that there are no bugs in the software applied to any drive by wire system. It is for this reason that the rules of FSAE state that Drive By Wire is not to be used under any circumstances\cite{FSAE_inspection}\cite{FSAE_rules}. This is well justified, since the results of accidentally implementing an unstable PID controller or any similar mistake could be catastrophic when that unstable controller is applied to the throttle position. However, despite the intended purpose of this device being inappropriate for an FSAE application, the DBW-4 documentation states that it can also be used as a general device to provide actuation and control to servo motors other than the throttle position\cite{DBW4_manual}. Despite this being very close to the functionality that the Carduino was intended to provide, there are several aspects of the DBW-4 which do not align with the criteria set for the Carduino solution. Firstly, the DBW-4 is obviously a MOTEC product, and as such comes with the closed source software and CAN protocol that the Carduino solution is supposed to be providing an alternative to. The fact that it is a MOTEC product also makes its price an inhibiting factor. The purpose of the Carduino is to provide an entry level solution to interfacing with the CAN bus such that any FSAE engineer or motor enthusiast would be able to have access to as many of these devices as desired. With a RRP of \$1,155\cite{MOTEC_prices}, the DBW-4 hardly caters to this purpose. Finally, the DBW-4 is an extremely complicated device, offering fully implemented PID controllers in response to messages sent via the CAN bus. While this is an excellent feature to be provided with when the user knows exactly what is to be implemented, the Carduino is designed to be a platform for the development of a wide variety of systems, which may or may not require a PID control network. The signal required from the Carduino to interface with the system it is controlling may be as simple as a logical high or low, or a communication protocol such as UART, RS232, SPI or anything else required by the engineer. By using the DBW-4, the user would be locked into only being able to create systems which used a servo motor as the actuator.

\subsubsection{Team Designed PCB}
With the Arduino shield not being physically tough enough, and the DBW-4 failing on several other fronts, the team looked into designing a Printed Circuit Board (PCB) that would provide the desired functionality. A PCB is a silicon wafer that can be designed through the use of software such as Altium to provide connectivity between relevant pins of surface mount components. In order to design a PCB, the engineer chooses the components desired in their device, and then arranges those components on a chip with copper tracks connecting all areas of the board which require connectivity. This would provide a professional and robust physical form for our device, capable of being made sufficiently small so as to be practical in an automotive environment.

In order to allow a circuit such as this to be programmed by an engineer, it required an onboard microcontroller with suitable processing power to perform any tasks required. It was also required that the solution offers an interface to the CAN bus. So this would have to be achieved either through the microcontroller itself or an extra chip such as the MCP2515 present on the CAN Arduino shields\cite{CAN_arduinoshield}. A parametric search on microcontrollers available from online electrical component retailers revealed a version of the ATMEGA16 which incorporated the ability to use the CAN protocol for communications out of two pins, called the ATMEGA16M1-AU\cite{ATMEGA16M1_datasheet}. This chip would provide both the option to implement programs based on sensor inputs, as well as the ability to communicate via the CAN bus. However one of the other criterion that had been set for our device was that it should be easily programmable by the end user, in order to create a truly user friendly product. One of the disadvantages to using this chip is the fact that it does not feature the popular debugging and flashing interface, IEEE 1149.1 - Joint Test Action Group (JTAG)\cite{ATMEGA16M1_datasheet}. This programming interface is commonly found on PCBs for the uploading and testing of programs onto the microcontrollers present onboard the PCB. At Melbourne University, there are several courses offered which teach the skills required to implement a device using the JTAG protocol, and as such the Electrical Subteam are familiar with this method. The fact that this chip did not offer the JTAG interface presented a significant challenge, since the basic method of programming and debugging the chip was unknown, and research was required. It was found that in order to upload programs to the chip, an In System Programmer (ISP) such as the AVR Dragon would need to be purchased by the user. This allowed the user to utilise the other debug methods available on the chip, such as debugWIRE\texttrademark\cite{ATMEGA16M1_datasheet}. These ISP devices can cost upwards of \$60\cite{AVRDRAGON_price}, and would rarely be owned by someone not heavily involved with the programming of microcontrollers. What's more, a specific set of programs, such as AVRDude or ATmel Studio are required to be set up accordingly to work correctly with any device that wants to interface with an ISP. This is often a non trivial process, and is extremely prone to complicated issues arising involving ISP compatibility. The steps involved in programming a device using a method such as this goes against the objective of the system to be an entry level solution to interfacing with the CAN Bus.

\subsubsection{Arduino based PCB}
Since the equipment and user skillset required for programming the ATMega16M1-AU did not meet the requirements for our device, research was done into methods for creating boards with easily programmable interfaces. The Arduino corporation has revolutionised the field of electrical engineering by introducing an entry level to microcontroller based systems available to users of all levels of microcontroller familiarity. Arduino's self contained and well documented Integrated Development Environment (IDE) makes the creation and uploading of programs onto Arduinos an easy task. As well as neatly handling the software aspects of creating a microcontroller based solution, Arduinos offer a USB interface which ensures that no extra devices are required to physically interface with their boards\cite{ARDUINO_gettingstarted}. The only issue with the Arduino platform is that the boards themselves are excessively large, and would be inappropriate for an automotive environment. 

It was discovered that there are instructions for emulating an Arduino on a breadboard available from the Arduino website, entitled Arduino to Breadboard\cite{ARDUINO_breadboard}. The method involves the use of PDIP package of the ATMega328p, a form factor designed for use where the chip is to be mounted either on a breadboard or in a PDIP holder so that the chip may be easily swapped out for another chip of the same form factor. The ATmega328P in the PDIP package is the microcontroller used onboard all Arduino Unos. A breadboard is a commonly used device amongst electrical engineering for the prototyping of circuits, offering the ability to easily hold through-hole components in place and provide connectivity between them. The tutorial details how the Arduino Bootloader can be flashed onto the device using the USB interface in an existing Arduino. A bootloader is a set of instructions which inform the device how incoming instructions are to be processed, similarly to a header file in a c project. Once the bootloader is on the ATmega328P, the breadboard may then be programmed as if it were an Arduino, by once again using the USB interface in an existing Arduino. A breadboard based solution however would obviously not fulfill the requirements for our device to be vibration proof, heat proof or water proof. Thus the Arduino to Breadboard tutorial would need to be modified such that it was implemented on a PCB. All Arduino hardware is licensed under a Creative Commons Attribution Share-Alike 3.0 license, which allows for both personal and commercial derivative works, as long as Arduino is credited and the designs to the works are released under the same license (find actual documentation for this). The Arduino to Breadboard tutorial falls under this same license, so the team is able to legally use the basic infrastructure detailed in the tutorial to create a smaller and more appropriate version of the Arduino to Breadboard solution for their own purposes. The Arduino software that would be used as detailed in the Arduino to Breadboard tutorial is Open Source and released under the GNU Public License, allowing maximum freedom in how we interact with the device created. This means that a miniaturised version of the Arduino to Breadboard tutorial would fulfil all criteria regarding ease of programming, form factor, and would deliver most of the functionality required.

\subsubsection{SPI CAN Bus Chip}
The only remaining functionality not provided by such a device would be the connectivity with the CAN bus that was now missing from the board by replacing the ATMEGA16M1-AU with the ATMEGA328p, which does not feature the ability to directly output the CAN protocol\cite{ATMEGA328P_datasheet}. Fortunately the ATMEGA328p does feature the ability to interface with peripheral devices via the Serial Peripheral Interface (SPI). This means that a device which allows SPI instructions to be converted to CAN messages could be introduced to the final board in order to provide CAN bus functionality\cite{MCP2515_datasheet}.

There are relatively few Integrated Circuits (IC) which provide the functionality required to provide a CAN interface to a microcontroller which only offers SPI output. The two options are Microchip Technology Inc's MCP2515\cite{MCP2515_datasheet} and Freescale Semiconductor's 33742\cite{33742_datasheet}. The datasheets of both these devices were inspected and the conclusion was reached that the datasheet for the MCP2515 provided a far more comprehensive overview of the operation of the device. It was also noted that the Arduino shield from Sparkfun\cite{CAN_arduinoshield} had included the MCP2515, and thus there was fairly good documentation for the chip online.

\subsection{Conclusion}
The Arduino shields met the requirements in terms of ease of use and programmability, but were lacking in their form factor. The MOTEC solution was overpriced, closed source, and featured technology that was overkill for the requirements of the project. The self designed PCBs would have whatever form factor we desired, but if a chip which incorporated the CAN interface itself were to be used, the device would lack the ability for the average motor enthusiast or even FSAE engineer to program it. The PCB approach was however was still decided to be the most appropriate form factor for the device. This meant that the best way to make this device would be by implementing a chip which emulated an Arduino, and provided an SPI link to the MCP2515 for interfacing with the CAN Bus. Due to its fundamental use of the open source Arduino platform, the project was named the Carduino, due to the intended use of the device being inside cars.

\section{Implementation}
\subsection{PCB Design}
In order to implement the PCB which is to be used in the device, there are many factors which need to be considered regarding design of the PCB. Things like the final list of components used, the size of the board designed, the placement of crystals, and the positioning of chips and their pin configurations all needed to be considered when creating The Carduino. This was to ensure a reliable and professional product was delivered.

\subsubsection{Board Size}
One of the main advantages of the PCB approach over an Arduino and Arduino Shield combo was the reduced size. Because of this, it was important to ensure that the smallest possible board was designed. This meant that careful consideration needed to be given to the orientation and location
of all chips onboard the device. Multiple iterations of board design were undertaken, as can be seen in figures (images of board design). With each new iteration, the objective was always to achieve a smaller board design, whilst maintaining the same connectivity between components, and occasionally the introduction of new components, as will be detailed later in this report.

figures of altium models of the CARDUINO

\subsubsection{Connectivity with Arduino}
In order to both burn the bootloader and upload sketches to the Carduino, connections need to be made between the Arduino and the Carduino as detailed in the Arduino to Breadboard tutorial\cite{ARDUINO_breadboard}. In order to provide a user friendly experience, it would be inappropriate to require the user to make these connections themselves with wires and a breadboard as outlined in the tutorial. For this reason, the system was designed to utilise a 16 wire ribbon cable for all connections to and from the board, as pictured in figure (picture of ribbon cable). In order to interface with this ribbon cable, a 16 pin IDC connector(cite IDC) was used on the Carduino itself. The IDC header used can be seen in figure (idc header pic). In order to actually interface with the Arduino however, it was required that this ribbon cable have some form of breakout board from the IDC header to the Arduino. The most appropriate solution for this was the development of an Arduino shield specifically to provide connectivity between an Arduino and the Carduino. In order to achieve this, once the base components had been placed into an Altium schematic file, all nets\footnote{A net is the term used in Altium as a generic name for any point on the circuit, either a wire, chip pin or any other point which can be connected to other parts of the circuit.} which were identified to require connectivity with the Arduino were connected to a footer representing the IDC header. This initial footer layout can be seen in Figure (figure of IDC from Carduino). This header connection arrangement then became the basis for a second schematic, which included a component representing an Arduino shield. This can be seen in Figure(schematic of IDC in arduino shield). Once these headers in the Carduino and the Arduino shield file were synchronised, connectivity was assured between the Arduino and the Carduino if a ribbon cable were correctly implemented between the two IDC headers. This would greatly improve the reliability of the device, since one of the most error prone stages of circuit prototyping is issues involving the incorrect connection of wires. By providing an error proof method for connecting the Carduino to the Arduino, both ease of use and reliability of the board have been increased.

Ribbon cable
IDC Header 
Schematic of IDC from carduino
schematic of IDC in arduino shield

\subsubsection{Connectivity Between Components}
Details on PCB theory from ECD utilised in the design of the board.

\subsubsection{Bootloader Issues, Installing a Switch}
Details about troubleshooting the SPI port of the mcp2515, spi interference, installing the switch.

\subsection{Library Development}
Details about building a library from scratch since other available libraries introduced too many features and were too difficult to debug.

\section{Results}


